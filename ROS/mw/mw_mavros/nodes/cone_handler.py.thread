#!/usr/bin/env python

import cv2
from datetime import datetime
import math
import numpy as np
import sys
import threading
import time

import rospy
from std_msgs.msg import Bool, Float64, Int8
from sensor_msgs.msg import Imu, NavSatFix
from mavros_msgs.msg import OverrideRCIn, Waypoint
from mavros_msgs.srv import CommandLong, ParamGet, SetMode
from mw_video.msg import ConeLocation

nodeLock = threading.Lock()

class ConeHandler():
    def __init__(self):
        self.node_name = "mwConeHandler"
        self.is_manual = False
        self.avoid_direction = 0                    # 1 - Left, 2 - Right
        self.z_angular_velocity = 0.0
        self.cone_seen_time = datetime(1990, 1, 1)

        self.apm_steer2srv_tconst = 0.75
        self.apm_steer2srv_p = 1.8
        self.apm_steer2srv_i = 0.2
        self.apm_steer2srv_d = 0.005
        self.apm_steer2srv_imax = 1500
        self.apm_steer2srv_minspd = 1.0

        self.apm_rc1_max = 0
        self.apm_rc1_min = 0
        self.apm_rc1_rev = 0
        self.apm_rc1_trim = 0

        self.apm_rc3_trim = 0

        self.auto_kickstart = -1

        rospy.init_node(self.node_name)
        
        # What we do during shutdown
        rospy.on_shutdown(self.cleanup)
        
        rospy.wait_for_service('/mavros/set_mode')
        self.set_mode = rospy.ServiceProxy('/mavros/set_mode', SetMode)

        rospy.wait_for_service('/mavros/param/get')
        self.get_param = rospy.ServiceProxy('/mavros/param/get', ParamGet)

        self.rc_override_pub = rospy.Publisher("/mavros/rc/override", OverrideRCIn, queue_size = 1)
        self.search_pub = rospy.Publisher("/mw/search", Bool, queue_size = 1)
        self.sound_pub = rospy.Publisher("/mw/sound", Int8, queue_size = 1)

        self.avoid_sub = rospy.Subscriber("/mw/avoid_direction", Int8, self.avoid_callback, queue_size = 1)
        self.cone_sub = rospy.Subscriber("/mw/cone_location", ConeLocation, self.cone_callback, queue_size = 1)
        self.imu_sub = rospy.Subscriber("/mavros/imu/data", Imu, self.imu_callback, queue_size = 1)

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_TCONST')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_tconst = ret.real
        else:
            rospy.logerr("get_param(STEER2SRV_TCONST) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_P')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_p = ret.real
        else:
            rospy.logerr("get_param(STEER2SRV_P) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_I')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_i = ret.real
        else:
            rospy.logerr("get_param(STEER2SRV_I) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_D')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_d = ret.real
        else:
            rospy.logerr("get_param(STEER2SRV_D) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_IMAX')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_imax = ret.integer
        else:
            rospy.logerr("get_param(STEER2SRV_IMAX) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'STEER2SRV_MINSPD')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_steer2srv_minspd = ret.real
        else:
            rospy.logerr("get_param(STEER2SRV_MINSPD) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'RC1_MAX')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_rc1_max = ret.integer
        else:
            rospy.logerr("get_param(RC1_MAX) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'RC1_MIN')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_rc1_min = ret.integer
        else:
            rospy.logerr("get_param(RC1_MIN) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'RC1_REV')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_rc1_rev = ret.integer
        else:
            rospy.logerr("get_param(RC1_REV) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'RC1_TRIM')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_rc1_trim = ret.integer
        else:
            rospy.logerr("get_param(RC1_TRIM) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'RC3_TRIM')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.apm_rc3_trim = ret.integer
        else:
            rospy.logerr("get_param(RC3_TRIM) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.get_param(param_id = 'AUTO_KICKSTART')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret != None and ret.success:
            self.auto_kickstart = ret.real
        else:
            rospy.logerr("get_param(AUTO_KICKSTART) request failed. Check mavros logs")

        rospy.loginfo("%s: Ready." % self.node_name)
        rospy.loginfo("   _tconst= %f  _p= %f  _i= %f  _d= %f  _imax= %d  _minspd= %f" %
            (self.apm_steer2srv_tconst, self.apm_steer2srv_p, self.apm_steer2srv_i,
             self.apm_steer2srv_d, self.apm_steer2srv_imax, self.apm_steer2srv_minspd))
        rospy.loginfo("   rc1 _max= %d  _min= %d  _rev= %d  _trim= %d" %
            (self.apm_rc1_max, self.apm_rc1_min, self.apm_rc1_rev, self.apm_rc1_trim))
        rospy.loginfo("   rc3 _trim= %d" %
            (self.apm_rc3_trim))

    def avoid_callback(self, av):
        self.avoid_direction = av.data
        self.is_manual = False

    def imu_callback(self, imup):
        nodeLock.acquire()
        try:
            self.z_angular_velocity = math.degrees(imup.angular_velocity.z)
        finally:
            nodeLock.release()

    def cone_callback(self, cp):
        nodeLock.acquire()
        try:
            self.distance = cp.distance
            self.delta_heading = cp.heading
            self.cone_seen_time = datetime.now()
        finally:
            nodeLock.release()

        rospy.loginfo("distance: %f  delta_heading: %f" % (self.distance, self.delta_heading))

        if not self.is_manual:
            rospy.loginfo("%s: cone_callback - Set MANUAL" % (self.node_name))

            ret = None
            try:
                ret = self.set_mode(base_mode = 0, custom_mode = 'MANUAL')
            except rospy.ServiceException as ex:
                rospy.logerr(ex)

            if ret != None and ret.success:
                self.is_manual = True
            else:
                rospy.logerr("Request failed. Check mavros logs")

    def loginfo(self, s):
        rospy.loginfo(s)

    def cleanup(self):
        rospy.loginfo("Shutting down vision node.")

    def set_auto(self):
        rospy.loginfo("%s: continue AUTO" % self.node_name)

        if not self.is_manual:
            rospy.loginfo("%s: already set to AUTO" % self.node_name)
            return

        retry = 2
        while retry > 0:
            try:
                self.search_pub.publish(False)
            except:
                rospy.logerr("search_pub() exception")
                retry = retry - 1
            else:
                retry = 0

        retry = 2
        while retry > 0:
            try:
                self.sound_pub.publish(2)
            except:
                rospy.logerr("sound_pub() exception")
                retry = retry - 1
            else:
                retry = 0

        orc = OverrideRCIn();
        orc.channels[1] = 0
        orc.channels[3] = 0
        orc.channels[4] = 0
        orc.channels[5] = 0
        orc.channels[6] = 0
        orc.channels[7] = 0

        try:
            self.rc_override_pub.publish(orc)
        except:
            rospy.logerr("rc_override_pub() exception")

        ret = None
        try:
            ret = self.set_param(param_id = 'AUTO_KICKSTART',
                integer = 0, real = 0.0)
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret == None or not ret.success:
            rospy.logerr("set_param(AUTO_KICKSTART, 0.0) request failed. Check mavros logs")

        ret = None
        try:
            ret = self.set_mode(base_mode = 0, custom_mode = 'AUTO')
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if not ret.success:
            rospy.logerr("set_mode(0, AUTO) failed. Check mavros logs")

        time.sleep(0.2)

        ret = None
        try:
            ret = self.set_param(param_id = 'AUTO_KICKSTART',
                integer = 0, real = self.auto_kickstart)
        except rospy.ServiceException as ex:
            rospy.logerr(ex)

        if ret == None or not ret.success:
            rospy.logerr("set_param(AUTO_KICKSTART, %f) request failed. Check mavros logs" % self.auto_kickstart)

        self.is_manual = False

    def is_shutdown(self):
        return rospy.is_shutdown()

class RcUpdateSender(threading.Thread):
    def __init__(self, group = None, target = None, name = None,
                 args = (), kwargs = None, verbose = None):
        threading.Thread.__init__(self, group = group, target = target, name = name,
                                  verbose = verbose)
        self.args = args
        self.kwargs = kwargs
        self.cone_handler = self.args[0]

        self.z_angular_velocity = 0.0
        self.distance = 0.0
        self.delta_heading = 0.0
        self.last_time = datetime.now()
        self.last_out = 0.0
        self.integrator = 0.0

        return

    def run(self):
        orc = OverrideRCIn();
        orc.channels[1] = 0
        orc.channels[3] = 0
        orc.channels[4] = 0
        orc.channels[5] = 0
        orc.channels[6] = 0
        orc.channels[7] = 0

        release_sent = False
        cone_seen_time = datetime(1990, 1, 1)

        while not self.cone_handler.is_shutdown():
            if self.cone_handler.is_manual:
                nodeLock.acquire()
                try:
                    self.z_angular_velocity = self.cone_handler.z_angular_velocity
                    self.distance = self.cone_handler.distance
                    self.delta_heading = self.cone_handler.delta_heading

                    tdiff = self.cone_handler.cone_seen_time - cone_seen_time
                    if tdiff.total_seconds() != 0:
                        cone_seen_time = self.cone_handler.cone_seen_time
                        release_sent = False
                finally:
                    nodeLock.release()

                self.cone_handler.loginfo("rc thread z_ang= %f, dist= %f, delta_hdg= %f" % (self.z_angular_velocity, self.distance, self.delta_heading))

                if not release_sent:
                    tdiff = datetime.now() - cone_seen_time 
                    if tdiff.total_seconds() > 0.5:
                        self.cone_handler.set_auto()
                        release_sent = True
                    else:
                        orc.channels[0] = self.cone_handler.apm_rc1_trim + self.calc_steering(self.delta_heading)
                        orc.channels[2] = self.cone_handler.apm_rc3_trim + self.calc_throttle(self.distance)

                        self.cone_handler.loginfo("Send rc: %d %d" % (orc.channels[0], orc.channels[2]))
                        self.cone_handler.rc_override_pub.publish(orc)
            else:
                # Reinitalize state
                self.last_out = 0.0
                self.integrator = 0.0

            time.sleep(0.02)

        return

    def rc1_angle_to_pwm(self, angle):
        _high = 4500
        reverse_mul = 1
        if self.cone_handler.apm_rc1_rev == -1:
            reverse_mul = -1

        if angle * reverse_mul > 0:
            return int(reverse_mul * (angle * (self.cone_handler.apm_rc1_max - self.cone_handler.apm_rc1_trim)) / _high)
        else:
            return int(reverse_mul * (angle * (self.cone_handler.apm_rc1_trim - self.cone_handler.apm_rc1_min)) / _high)

    def constrain(self, v, nmin, nmax):
        return max(min(nmax, v), nmin)

    # Stolen & adapted from ardupilot/libraries/APM_Control/AP_SteerController.cpp
    def calc_steering(self, desired_rate):
        tnow = datetime.now()

        tdiff = tnow - self.last_time
        dt = tdiff.total_seconds() * 1000

        if dt > 1000:
            dt = 0

        self.last_time = tnow

        # XXX: find a better way for the speed
        speed = self.cone_handler.apm_steer2srv_minspd / 2

        # this is a linear approximation of the inverse steering
        # equation for a ground vehicle. It returns steering as an angle from -45 to 45
        scaler = 1.0 / speed

        # Calculate the steering rate error (deg/sec) and apply gain scaler
        rate_error = (desired_rate - self.z_angular_velocity) * scaler
        
        # Calculate equivalent gains so that values for K_P and K_I can be taken across from the old PID law
        # No conversion is required for K_D
        ki_rate = self.cone_handler.apm_steer2srv_i * self.cone_handler.apm_steer2srv_tconst * 45.0
        kp_ff = max((self.cone_handler.apm_steer2srv_p -
            self.cone_handler.apm_steer2srv_i * self.cone_handler.apm_steer2srv_tconst) *
            self.cone_handler.apm_steer2srv_tconst - self.cone_handler.apm_steer2srv_d , 0) * 45.0
        
        # Multiply roll rate error by _ki_rate and integrate
        # Don't integrate if in stabilise mode as the integrator will wind up against the pilots inputs
        if ki_rate > 0 and speed >= self.cone_handler.apm_steer2srv_minspd:
            # only integrate if gain and time step are positive.
            if dt > 0:
                integrator_delta = rate_error * ki_rate * dt * 0.001 * scaler
                # prevent the integrator from increasing if steering defln demand is above the upper limit
                if self.last_out < -45:
                    integrator_delta = max(integrator_delta , 0)
                elif self.last_out > 45:
                    # prevent the integrator from decreasing if steering defln demand is below the lower limit
                    integrator_delta = min(integrator_delta, 0)

                self.integrator += integrator_delta;
        else:
            self.integrator = 0.0
        
        # Scale the integration limit
        intLimScaled = self.cone_handler.apm_steer2srv_imax * 0.01

        # Constrain the integrator state
        self.integrator = self.constrain(self.integrator, -intLimScaled, intLimScaled)
        
        # Calculate the demanded control surface deflection
        self.last_out = (rate_error * self.cone_handler.apm_steer2srv_d * 4.0) + (math.radians(desired_rate) * kp_ff) * scaler + self.integrator
        
        # Convert to centi-degrees and constrain
        ret = self.constrain(self.last_out * 100, -4500, 4500)

        # self.cone_handler.loginfo("calc_steering target deg= %d" % ret)
        # Translate into servo value
        return self.rc1_angle_to_pwm(ret)

    def calc_throttle(self, distance):
        if distance < 3:
            return 84 # 77
        elif distance < 5:
            return 86 # 83
        else:
            return 95

class EndManualThread(threading.Thread):
    def __init__(self, group = None, target = None, name = None,
                 args = (), kwargs = None, verbose = None):
        threading.Thread.__init__(self, group = group, target = target, name = name,
                                  verbose = verbose)
        self.args = args
        self.kwargs = kwargs
        self.cone_handler = self.args[0]
        return

    def run(self):
        manual_start_time = None

        while not self.cone_handler.is_shutdown():
            if self.cone_handler.is_manual:
                if manual_start_time == None:
                    manual_start_time = datetime.now()

                elif self.cone_handler.avoid_direction != 3:
                    diff = datetime.now() - manual_start_time
                    if diff.total_seconds() > 60:
                        rospy.loginfo("EndManualThread in manual for %f, stopping search and go back to AUTO" % diff.total_seconds())
                        self.cone_handler.set_auto()

            else:
                manual_start_time = None

            time.sleep(1)

        return

def main(args):       
    try:
        c = ConeHandler()
        rc = RcUpdateSender(args = (c, ))
        rc.daemon = True
        rc.start()

        em = EndManualThread(args = (c, ))
        em.daemon = True
        em.start()

        rospy.spin()
    except KeyboardInterrupt:
        print "close"

if __name__ == '__main__':
    main(sys.argv)
    
